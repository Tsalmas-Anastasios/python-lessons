from pygame.math import Vector2


class GameObject:
    def __init__(self, position, sprite, velocity):
        self.position = Vector2(position)
        self.sprite = sprite
        self.radius = sprite.get_width() / 2
        self.velocity = Vector2(velocity)

    def draw(self, surface):
        blit_position = self.position - Vector2(self.radius)
        surface.blit(self.sprite, blit_position)

    def move(self):
        self.position = self.position + self.velocity

    def colides_with(self, other_obj):
        distance = self.position.distance_to(other_obj.position)
        return distance < self.radius + other_obj.radius


#
#
# Εξήγηση κώδικα
# --------------
#   Γραμμή 1
#   Εισάγει την κλάση Vector2 που αναφέρθηκε προηγουμένως
#
#   Γραμμή 3
#   Δημιουργεί την κλάση GameObject, την οποία θα χρησιμοποιήσουμε για να αναπαραστήσουμε
#   όλα τα αντικείμενα του παιχνιδιού στο Space Rocks
#
#   Γραμμή 4
#   Είναι ο κατασκευαστής της κλάσης GameObject. Χρειάζεται τρία ορίσματα:
#       1. position
#          Το κέντρο του αντικειμένου
#       2. sprite
#          Η εικόνα που χρησιμοποιήθηκε για τη σχεδίαση αυτού του αντικειμένου
#       3. velocity
#          Ενημερώνει το position του αντικειμένου σε κάθε καρέ
#
#   Γραμμή 5 & 8
#   Διασφαλίζουν ότι το position και το velocity θα αντιπροσωπεύονται πάντα ως διανύσματα για
#   μελλοντικούς υπολογισμούς, ακόμα κι αν οι πλειάδες περαστούν στον κατασκευαστή. Το κάνουμε
#   αυτό καλώντας την Vector2() κατασκευαστή. Αν του δοθεί πλειάδα, τότε θα δημιουργήσει ένα
#   νέο διάνυσμα από αυτή. Εάν του δοθεί ένα διάνυσμα, τότε θα δημιουργήσει ένα αντίγραφο του
#   διανύσματος.
#
#   Γραμμή 7
#   Υπολογίζει το radius σαν το μισό πλάτος του sprite. Σε αυτό το πρόγραμμα, τα sprites αντικειμένων
#   του παιχνιδιού, θα είναι πάντα τετράγωνα με διαφανές φόντο. Θα μπορούσαμε επίσης να
#   χρησιμοποιήσουμε το ύψος της εικόνας - δεν θα είχε καμία διαφορά.
#
#   Γραμμή 10
#   Ορίζει το draw(), το οποίο θα σχεδιάσει το sprite του αντικειμένου στην επιφάνεια και θα έχει
#   περαστεί ως όρισμα.
#
#   Γραμμή 11
#   Υπολογίζει τη σωστή θέση για το blitting της εικόνας. Διαδικασία:
#       - Παρατηρούμε ότι ο Vector2() κατασκευαστής, λαμβάνει έναν μόνο αριθμό αντί για μια πλειάδα.
#         Σε αυτή την περίπτωση, θα χρησιμοποιήσει τον αριθμό και για τις δύο τιμές. Έτσι το
#         Vector2(self.radius) είναι ισοδύναμο με το Vector2((self.radius, self.radius))
#
#   Γραμμή 12
#   Χρησιμοποιεί τη θέση blit που υπολογίστηκε πρόσφατα για να τοποθετήσει το sprite του αντικειμένου
#   μας στη σωστή θέση στη δεδομένη επιφάνεια.
#
#   Γραμμή 14
#   Ορίζει την move(). Θα ενημερώσει τη θέση του αντικειμένου του παιχνιδιού.
#
#   Γραμμή 15
#   Προσθέτει την ταχύτητα στη θέση και λαμβάνει ένα ενημερωμένο ιάνυσμα θέσης ως αποτέλεσμα. Το
#   Pygame κάνει τον χειρισμό διανυσμάτων απλό, επιτρέποντάς μας να τα προσθέτουμε σαν αριθμούς
#
#   Γραμμή 17
#   Ορίζει την colides_with() μέθοδο που θα χρησιμοποιηθεί για τον εντοπισμό των συγκρούσεων.
#
#   Γραμμή 18
#   Υπολογίζει την απόσταση μεταξύ δύο αντικειμένων χρησιμοποιώντας το Vector2.distance_to()
#
#   Γραμμή 19
#   Ελέγχει αν αυτή η απόσταση είναι μικρότερη από το άθροισμα των ακτίνων των αντικειμένων.
#   Αν ναι, τα αντικείμενα συγκρούονται.
#
#
# Ας λάβουμε υπόψη ότι τα αντικείμενα του παιχνιδιού μας έχουν κεντρική θέση, αλλά η blit() απαιτεί
# την επάνω αριστερή γωνία. Έτσι η θέση στην οποία τοποθετεί η blit πρέπει να υπολογιστεί μετακινώντας
# την πραγματική θέση του αντικειμένου κατά ένα διάνυσμα. Αυτή η διαδικασία συμβαίνει στο draw().
#
#
#
#
#       Επιστρέφουμε στο game.py --><--


# Δημιουργία κλάσης για το Διαστημόπλοιο
# --------------------------------------
#

from pygame.math import Vector2
from utils import load_sprite


class Spaceship(GameObject):
    def __init__(self, position):
        super().__init__(position, load_sprite("spaceship"), Vector2(0))


# Δεν κάνει πολλά σε αυτό το σημείο - απλώς καλεί τον κατασκευαστή
# της GameObject με μια συγκεκριμένη εικόνα και με μηδενική
# ταχύτητα.
